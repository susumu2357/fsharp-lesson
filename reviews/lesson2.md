# 第二回 「Relational Algebraの処理系、ToyRelを作ろう」の感想

2022年8月1日に最初のコミットをしていて8月31日に終えたので、完走まで丸一ヶ月かかったことになります。
比較的時間が使える状況にあっても一ヶ月かかったのでそれなりに大変ですが、全て実装し終えてRelational Algebraの操作が一通りできるようになると感慨深いものがあります。

コードを見てもらうと、改善点が認識できるだけでなく、良いコードが書けているかどうか確認できるというのが助かりました。一人で書いていると、良い感じがするけど本当にそうなのか自信が無いということがありますが、レビューしてもらって良く書けていると言ってもらえると自信を持って進むことができました。


多くを学びました。自分の中で特に重要だった場面を振り返ります。

## Abstract Data Type (ADT)の実践
Relation moduleというADTをつくり、リレーションの生成や保存をひとまとめにすることでADTを学びました。
ADTとしてひとまとめにすることでリレーションという対象がくっきり浮かぶようになり、リレーションがどういうものなのか、どういうものにしたいのか、ということについて自覚的になれました。

どこからどこまでをmoduleに含めるかが悩ましいところですが、今後何度かADTを作れば自分なりの塩梅が見つかるのかなと思いました。積極的に使っていきたい手法です。

## F#のコンパイル順序
大変良い仕様だと感じました。
融通が利かないという批判的な意見もネットで目にしたのですが、私はむしろ順序が固定されている方がコードが読みやすくて良いと思います。
また、モジュールの依存関係を意識するためにも良い仕組みだと思います。

## エラー処理
「課題14: エラー処理を実装する」は、個人的に第二回のハイライトでした。
元々、Fun and Profitおよび同著者の本を読んでいてResultを用いたエラー処理をしっかりできるようになりたいと思っていたので、時間をかけて勉強しました。
おかげでちゃんと理解できたし、使えるようになったと思います。
Computation expressionsというものがあることも学びましたが、私はどうも分かりやすくなっている感じがせず、bindとかmapをそのまま使う方が好きでした。

モナドの入門になったのも良かったです。モナドにこだわるつもりは無いのですが、関数型言語の記事を読む際に知っているとスムーズですし、不必要な混乱も避けられます。応用も利きます。例えば、Optionモナド（Maybeモナド）はResultとほとんど同じなので、すぐに使えるようになりました。

それにしても、モナドという言葉がプログラミング業界に輸入されたのは不幸なことだと思います。どれだけ多くのプログラマに無駄な勉強をさせたのでしょう。

## restrict
もう一つのハイライトは、restrictの実装だったと思います。
一気に完成版をつくることが出来ず、とりあえずの実装を何回かに分けてリファクタするという感じで進めました。
仕事でコードを書く場合はとりあえず動けば満足してしまうことが多いので、綺麗に書けるまで改善を繰り返すという経験は貴重でした。

この頃には実装の方針が頭の中で出来ればコンパイラの助けだけで大体書けるようになっていましたが、Deedleにはいつも苦労させられました。正直、Deedleを使わずにSeqやListだけ使う方が素早く実装できたのではないかと思います。

## Catamorphism
もう一つ学んで役に立ったと思うのがCatamorphismです。
それ自体応用が利くエレガントな手法だと思いますが、個人的には、関数の引数として関数を渡す感覚が少し向上するという副次効果がありました。
具体的には、第二回の最後に
```F#
let infixOperation rel1 rel2 computeRelation =
    ...
```
という関数をつくっていて、この`computeRelation`が関数になっています。
`difference`, `union`, `intersect`という3種類の演算をまとめるために上記`infixOperation`を作ったのですが、異なる演算を表す柔軟性を保ちつつ、共通部分を括り出すのにこういった書き方が丁度良いということが分かりました。
慣れると簡潔に書けて非常に便利です。

## Ionideのバグ？
第二回も半分を越したあたりからIonideが正常に動作せず、Reload Windowを強いられることが増えました。
例えば、
```F#
let functionDef val1 val2 =
 ...
```
というコードがあるとして、Ionideが自動で
```F#
let functionDef val1: string val2: SomeType =
 ...
```
といった具合に型を補完してくれるのですが、これがバグって、
```F#
let functionDef val1: string va: SomeType l2 =
 ...
```
という感じになってしまうことがありました。当然ながらその後の補完は滅茶苦茶になり、警告だらけになります。
発生条件がよく分からず、リロード以外に直す方法が分かっていません。

## F#だと数学の能力がプログラム能力向上に活かせるのか
[ポッドキャスト第205回](https://anchor.fm/karino2/episodes/205-F-e1mk2hi)を聞きました。
F#というかたぶん関数型言語全般は、対象を抽象化する頭の使い方が数学におけるそれと似ているのかなと思いました。つまり、具体例を抽象化、一般化して話しを進める態度が役に立っている感じがします。数学は、何でもかんでも一般化すれば良いというものではなくて、絶妙な抽象具合だったり、自然な抽象化という感覚があって、そういう感覚が関数型言語の抽象化志向にマッチしているのではないかと思います。

例えば、Catamorphismは再帰的なパターンマッチに現れる構造の骨組みだけ残したらどうなるか考えてみようという感じで、この抽象具合はPythonでは出会わない高度なものだと思います。繰り返しになりますが、抽象度が高ければ良いというものではないのですが、それが自然な選択であれば使えるというのは大事なことだと思います。使いどころが分からないとか、何でも抽象化して無理に使ってしまうとか、そういうことにならなければ良くて、そのために数学の経験が活きてくるのではないでしょうか。
